"""
Models.py
*****************
This file contains all of the models used in the database.
To add more models, simply append them here.
"""

from django.db import models
from django.core.exceptions import ValidationError
from django.utils.translation import gettext_lazy
from django.contrib.auth.models import User
from django.db.models.signals import post_save
from django.dispatch import receiver

from modelcluster.fields import ParentalKey
from wagtail.core.models import Page, Orderable
from wagtail.core.fields import RichTextField
from wagtail.admin.edit_handlers import FieldPanel, InlinePanel
from wagtail.images.edit_handlers import ImageChooserPanel
from wagtail.search import index

from django_select2.forms import Select2Widget
from colorfield.fields import ColorField


# Create your models here.
class Activity(models.Model):
    """
    Model for an 'Activity'. These are mapped to 'Outcomes' using the
    ActivOut model.

    Attributes
    ---------
    name : CharField
        The name of the activity, e.g 'Mental Health Programs'
    description : CharField
        The description of the activity
    """

    name = models.CharField(max_length=50,
                            help_text="The name of the activity")
    description = models.TextField(help_text="A description of the activity")

    def __str__(self):
        return self.name


class Outcome(models.Model):
    """
    Model for an 'Outcome'. These are mapped to 'Activities' using the
    ActivOut model.

    Attributes
    ---------
    name : CharField
        The name of the outcome, e.g 'Increased social confidence'
    description : CharField
        The description of the outcome
    """
    name = models.CharField(max_length=50,
                            help_text="The name of the outcome")
    description = models.TextField(help_text="A description of the outcome")

    def __str__(self):
        return self.name


class ActivOut(models.Model):
    """
    ActivOut model that maps an activity to an outcome

    Attributes
    ---------
    activity : Activity
        The Activity to be mapped
    outcome : Outcome
        The outcome to be mapped
    """
    # preserve the activity outcome pair
    activity = models.ForeignKey(Activity, on_delete=models.SET_NULL, null=True,
                                 help_text="The activity in the activity-outcome pair")
    outcome = models.ForeignKey(Outcome, on_delete=models.SET_NULL, null=True,
                                help_text="The outcome in the activity-outcome pair")

    # my name is activity -> outcome
    def __str__(self):
        return self.activity.name + "->" + self.outcome.name

    # unique pairs only!
    class Meta:
        unique_together = ('activity', 'outcome')


class EmbedLink(models.Model):
    """
    Model for an EmbedLink. These are the links generated by Kumu that 
    display a particular view.

    Attributes
    ---------
    type : GALAXY_TYPE_CHOICES
        The type of the embed link (Galaxy, Constellation or Universe)
    universeName : CharField
        Name to be displayed if this is a universe. 
        Else the relatedElement's label will take this place.
    description : TextField
        Description of the embed link
    mapSlug : SlugField
        The kumu slug of the map
    viewSlug : SlugField
        The slug of the particular view to be rendered
    embedURL : URLField
        The embed link itself, as a URL

    ---------
    URL Parameters for kumu
    ---------
    bare 
        No controls present on the map
    simple
        Zoom only
    scroll
        Enables scrolling to zoom, usually disabled
    """
    # Galaxy Options
    GALAXY = "G"
    CONSTELLATION = "C"
    UNIVERSE = "U"
    GALAXY_TYPE_CHOICES = (
        (GALAXY, "Galaxy"),
        (CONSTELLATION, "Constellation"),
        (UNIVERSE, "Universe")
    )
    # fields
    type = models.CharField(max_length=1, choices=GALAXY_TYPE_CHOICES)
    universeName = models.CharField(max_length=50,
                                    help_text="Name to be displayed if this is a universe. \
                                    Else the relatedElement's label will take this place.",
                                    default="NotAUniverse")
    description = models.TextField()
    mapSlug = models.SlugField()
    viewSlug = models.SlugField()
    embedURL = models.URLField(max_length=255)

    # URL PARAMETERS FOR KUMU - Bare (no controls) Simple - Zoom only scroll - enables scroll to zoom
    bare = models.BooleanField(help_text="")
    simple = models.BooleanField(help_text="")
    scroll = models.BooleanField(help_text="")

    def __str__(self):
        element = self.relatedElement.first()
        if element:
            return element.label + " (" + self.get_type_display() + ")"
        else:
            return self.universeName + " (" + self.get_type_display() + ")"

    class Meta:
        permissions = (
            ("view_map", "Can view the insight map (is a paying customer)"),
        )


class Element(models.Model):
    """
    Model for an Element on the map. These can be at any level.

    Attributes
    ---------
    label : CharField
        The label for the element as shown on the map
    description : TextField
        A description of the element as shown in the sidebar
    type : GALAXY_TYPE_CHOICES
        The type of the element (Galaxy, Constellation or Universe)
    tags : EmbedLink
        EmbedLink tag used by kumu. This represents the parent of the element,
        and tells kumu which elements to display when the parent element is visited.
        This allows elements to have multiple parents - e.g a star can be visited from multiple
        constellations
    activOuts : ActivOut
        Used only for 'star' elements, these represent the activites and outcomes mapped this element.
    child : Element
        Used in rare cases when there are elements of the same name at different levels on the map.
    relatedView: EmbedLink
        The related view in kumu of this element, i.e where 'clicking down' on this element
        will go to. 
    """
    # Galaxy Options
    GALAXY = "G"
    CONSTELLATION = "C"
    STAR = "S"
    GALAXY_TYPE_CHOICES = (
        (GALAXY, "Galaxy"),
        (CONSTELLATION, "Constellation"),
        (STAR, "Star")
    )
    # model Fields
    label = models.CharField(max_length=50,
                             help_text="The label for the element as shown on the map")
    description = models.TextField(help_text="A description of the element as shown in the sidebar")
    type = models.CharField(max_length=14, choices=GALAXY_TYPE_CHOICES,
                            help_text="The type of the element: galaxy, constellation, or star")
    tags = models.ManyToManyField(EmbedLink, related_name='elements',
                                  help_text="")
    activOuts = models.ManyToManyField(ActivOut, related_name='elements', blank=True,
                                       help_text="For stars: activity-outcome pairs related to this issue")
    child = models.ForeignKey('self', on_delete=models.SET_NULL, null=True, related_name='parent', blank=True,
                              help_text="")
    relatedView = models.ForeignKey(EmbedLink, on_delete=models.SET_NULL, blank=True, null=True,
                                    related_name='relatedElement',
                                    help_text="")

    def __str__(self):
        return self.label + " (" + self.get_type_display() + ")"


class UserInterest(models.Model):
    """
    User Interest model. Simply maps an ActivOut to a Star
    """
    activOut = models.ForeignKey(ActivOut, on_delete=models.CASCADE)
    element = models.ForeignKey(Element, on_delete=models.CASCADE)

    class Meta:
        unique_together = ('activOut', 'element')


class UserAttributes(models.Model):
    """
    User attributes model. Maps a user to user interests
    """
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='userattributes')
    interests = models.ManyToManyField(UserInterest, blank=True)

    @receiver(post_save, sender=User)
    def create_user_attributes(sender, instance, created, **kwargs):
        if created:
            UserAttributes.objects.create(user=instance)

    @receiver(post_save, sender=User)
    def save_user_attributes(sender, instance, **kwargs):
        instance.userattributes.save()


class Connection(models.Model):
    """
    Model for a connection between elements. Essentially maps two elements to each other

    Attributes
    ----------
    a : Element
        An element
    b : Element
        Another element
    direction : CharField
        The direction of the connection, should usually be undirected
    """
    # Direction Options
    UNDIRECTED = "UND"
    DIRECTED = "DIR"
    MUTUAL = "MUT"
    DIRECTION_CHOICES = (
        (UNDIRECTED, "undirected"),
        (DIRECTED, "directed"),
        (MUTUAL, "mutual")
    )
    # model Fields
    # from = a, to = b. Python Keywords
    a = models.ForeignKey(Element, on_delete=models.SET_NULL, null=True, to_field="id", related_name="a",
                          help_text="The first element to be connected")
    b = models.ForeignKey(Element, on_delete=models.SET_NULL, null=True, to_field="id", related_name="b",
                          help_text="The second element to be connected")
    direction = models.CharField(max_length=3, choices=DIRECTION_CHOICES, default="UND",
                                 help_text="The direction of the connection, should usually be undirected")

    def clean(self):
        """
        Maintains order between connections.
        Checks if a connection already exists in both a->b and b->a forms
        """
        thisObject = self
        objectBs = Connection.objects.filter(b=thisObject.b)
        objectAs = Connection.objects.filter(b=thisObject.a)
        for connection in objectBs:
            if connection.a == thisObject.a:
                # this would be a copy of the current
                raise ValidationError(gettext_lazy('This connection already exists'))
        for connection in objectAs:
            # check where this value is in another connections a spot
            if connection.a == thisObject.b:
                # if that object has our a in their b we are a reverse copy!
                raise ValidationError(gettext_lazy('This connection already exists in the opposite form (a->b, b->a)'))

    def __str__(self):
        return self.a.label + " --> " + self.b.label


"""
Blogging models, for pages etc
"""


class StarBlogPage(Page):
    """
    Model for a blog page specifically for stars. These will display the activouts that are mapped to star. 

    Attributes
    ----------
    date : DateField
        When the page was last updated
    element : Element
        The star on the map that page maps to. Form only shows stars. 
    body : RichTextField
        The body of the blog page. This is appended to the description of the element. 
    """
    date = models.DateField("Updated on")
    element = models.ForeignKey(Element, on_delete=models.SET_NULL, null=True, to_field="id",
                                related_name="starBlogPage", limit_choices_to={'type': 'S'})
    body = RichTextField(blank=True)
    colour = ColorField(default='#FFFFFF')

    # Search fields 
    search_fields = Page.search_fields + [
        index.SearchField('body'),
    ]
    # Content panels: These display as fields on the form
    content_panels = Page.content_panels + [
        FieldPanel('date'),
        FieldPanel('element', widget=Select2Widget),
        FieldPanel('colour'),
        FieldPanel('body', classname="full"),
    ]


class NodeBlogPage(Page):
    """
    Model for a blog page for any element that is not a star. 

    Attributes
    ----------
    date : DateField
        When the page was last updated
    element : Element
        The star on the map that page maps to. Form only shows stars. 
    body : RichTextField
        The body of the blog page. This is appended to the description of the element. 
    """
    date = models.DateField("Updated on")
    element = models.ForeignKey(Element, on_delete=models.SET_NULL, null=True, to_field="id", related_name="blogPage",
                                limit_choices_to={'type': 'G', 'type': 'C'})
    body = RichTextField(blank=True)

    search_fields = Page.search_fields + [
        index.SearchField('body'),
    ]

    content_panels = Page.content_panels + [
        FieldPanel('date'),
        FieldPanel('element', widget=Select2Widget),
        FieldPanel('body', classname="full"),
    ]


class BlogPageGalleryImage(Orderable):
    """
    Model for an image on a page.
    """
    page = ParentalKey(StarBlogPage, on_delete=models.CASCADE, related_name='gallery_images')
    image = models.ForeignKey('wagtailimages.Image', on_delete=models.CASCADE, related_name='+')
    caption = models.CharField(blank=True, max_length=250)
    panels = [
        ImageChooserPanel('image'),
        FieldPanel('caption'),
    ]
